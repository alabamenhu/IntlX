unit module Intl::X;

# The "loaded" language
my $language = 'es';

# All exceptions are stored here, where keys are language tags,
# and values are a hash of exception type names.
my %x;

# When in doubt, we can always simply
my \ENGLISH = method ($self:){ callsame }

#| Loads the exceptions for a given language.
sub load-language($code) {
    my $module = "Intl::X::$code";
    try require ::($module);
    if ::($module) ~~ Failure {
        # TODO: error handling
    } else {
        %x{$code} := ::($module ~ "::%exceptions");
    }
}


load-language('es');

#####################################################
### AUTOGENERATED ! AUTOGENERATED ! AUTOGENERATED ###
#####################################################
###  DO NOT EDIT THIS BOX OR ANYTHING BENEATH IT  ###
#####################################################

CX::Done.^find_method('message').wrap(%x{$language}<CX::Done>//ENGLISH);
say 'wrapped CX::Done';
CX::Emit.^find_method('message').wrap(%x{$language}<CX::Emit>//ENGLISH);
say 'wrapped CX::Emit';
CX::Last.^find_method('message').wrap(%x{$language}<CX::Last>//ENGLISH);
say 'wrapped CX::Last';
CX::Next.^find_method('message').wrap(%x{$language}<CX::Next>//ENGLISH);
say 'wrapped CX::Next';
CX::Proceed.^find_method('message').wrap(%x{$language}<CX::Proceed>//ENGLISH);
say 'wrapped CX::Proceed';
CX::Redo.^find_method('message').wrap(%x{$language}<CX::Redo>//ENGLISH);
say 'wrapped CX::Redo';
CX::Return.^find_method('message').wrap(%x{$language}<CX::Return>//ENGLISH);
say 'wrapped CX::Return';
CX::Succeed.^find_method('message').wrap(%x{$language}<CX::Succeed>//ENGLISH);
say 'wrapped CX::Succeed';
CX::Take.^find_method('message').wrap(%x{$language}<CX::Take>//ENGLISH);
say 'wrapped CX::Take';
CX::Warn.^find_method('message').wrap(%x{$language}<CX::Warn>//ENGLISH);
say 'wrapped CX::Warn';
Exception.^find_method('message').wrap(%x{$language}<Exception>//ENGLISH);
say 'wrapped Exception';
Exceptions::JSON.^find_method('message').wrap(%x{$language}<Exceptions::JSON>//ENGLISH);
say 'wrapped Exceptions::JSON';
X::AdHoc.^find_method('message').wrap(%x{$language}<X::AdHoc>//ENGLISH);
say 'wrapped X::AdHoc';
X::Adverb.^find_method('message').wrap(%x{$language}<X::Adverb>//ENGLISH);
say 'wrapped X::Adverb';
X::Anon::Augment.^find_method('message').wrap(%x{$language}<X::Anon::Augment>//ENGLISH);
say 'wrapped X::Anon::Augment';
X::Anon::Multi.^find_method('message').wrap(%x{$language}<X::Anon::Multi>//ENGLISH);
say 'wrapped X::Anon::Multi';
X::ArrayShapeMismatch.^find_method('message').wrap(%x{$language}<X::ArrayShapeMismatch>//ENGLISH);
say 'wrapped X::ArrayShapeMismatch';
X::Assignment::ArrayShapeMismatch.^find_method('message').wrap(%x{$language}<X::Assignment::ArrayShapeMismatch>//ENGLISH);
say 'wrapped X::Assignment::ArrayShapeMismatch';
X::Assignment::RO.^find_method('message').wrap(%x{$language}<X::Assignment::RO>//ENGLISH);
say 'wrapped X::Assignment::RO';
X::Assignment::RO::Comp.^find_method('message').wrap(%x{$language}<X::Assignment::RO::Comp>//ENGLISH);
say 'wrapped X::Assignment::RO::Comp';
X::Assignment::ToShaped.^find_method('message').wrap(%x{$language}<X::Assignment::ToShaped>//ENGLISH);
say 'wrapped X::Assignment::ToShaped';
X::Attribute::NoPackage.^find_method('message').wrap(%x{$language}<X::Attribute::NoPackage>//ENGLISH);
say 'wrapped X::Attribute::NoPackage';
X::Attribute::Package.^find_method('message').wrap(%x{$language}<X::Attribute::Package>//ENGLISH);
say 'wrapped X::Attribute::Package';
X::Attribute::Regex.^find_method('message').wrap(%x{$language}<X::Attribute::Regex>//ENGLISH);
say 'wrapped X::Attribute::Regex';
X::Attribute::Required.^find_method('message').wrap(%x{$language}<X::Attribute::Required>//ENGLISH);
say 'wrapped X::Attribute::Required';
X::Attribute::Scope::Package.^find_method('message').wrap(%x{$language}<X::Attribute::Scope::Package>//ENGLISH);
say 'wrapped X::Attribute::Scope::Package';
X::Attribute::Undeclared.^find_method('message').wrap(%x{$language}<X::Attribute::Undeclared>//ENGLISH);
say 'wrapped X::Attribute::Undeclared';
X::Augment::NoSuchType.^find_method('message').wrap(%x{$language}<X::Augment::NoSuchType>//ENGLISH);
say 'wrapped X::Augment::NoSuchType';
X::Backslash::NonVariableDollar.^find_method('message').wrap(%x{$language}<X::Backslash::NonVariableDollar>//ENGLISH);
say 'wrapped X::Backslash::NonVariableDollar';
X::Backslash::UnrecognizedSequence.^find_method('message').wrap(%x{$language}<X::Backslash::UnrecognizedSequence>//ENGLISH);
say 'wrapped X::Backslash::UnrecognizedSequence';
X::Bind.^find_method('message').wrap(%x{$language}<X::Bind>//ENGLISH);
say 'wrapped X::Bind';
X::Bind::NativeType.^find_method('message').wrap(%x{$language}<X::Bind::NativeType>//ENGLISH);
say 'wrapped X::Bind::NativeType';
X::Bind::Slice.^find_method('message').wrap(%x{$language}<X::Bind::Slice>//ENGLISH);
say 'wrapped X::Bind::Slice';
X::Bind::ZenSlice.^find_method('message').wrap(%x{$language}<X::Bind::ZenSlice>//ENGLISH);
say 'wrapped X::Bind::ZenSlice';
X::Buf::AsStr.^find_method('message').wrap(%x{$language}<X::Buf::AsStr>//ENGLISH);
say 'wrapped X::Buf::AsStr';
X::Buf::Pack.^find_method('message').wrap(%x{$language}<X::Buf::Pack>//ENGLISH);
say 'wrapped X::Buf::Pack';
X::Buf::Pack::NonASCII.^find_method('message').wrap(%x{$language}<X::Buf::Pack::NonASCII>//ENGLISH);
say 'wrapped X::Buf::Pack::NonASCII';
X::Caller::NotDynamic.^find_method('message').wrap(%x{$language}<X::Caller::NotDynamic>//ENGLISH);
say 'wrapped X::Caller::NotDynamic';
X::Cannot::Capture.^find_method('message').wrap(%x{$language}<X::Cannot::Capture>//ENGLISH);
say 'wrapped X::Cannot::Capture';
X::Cannot::Empty.^find_method('message').wrap(%x{$language}<X::Cannot::Empty>//ENGLISH);
say 'wrapped X::Cannot::Empty';
X::Cannot::Junction.^find_method('message').wrap(%x{$language}<X::Cannot::Junction>//ENGLISH);
say 'wrapped X::Cannot::Junction';
X::Cannot::Lazy.^find_method('message').wrap(%x{$language}<X::Cannot::Lazy>//ENGLISH);
say 'wrapped X::Cannot::Lazy';
X::Cannot::Map.^find_method('message').wrap(%x{$language}<X::Cannot::Map>//ENGLISH);
say 'wrapped X::Cannot::Map';
X::Cannot::New.^find_method('message').wrap(%x{$language}<X::Cannot::New>//ENGLISH);
say 'wrapped X::Cannot::New';
X::Comp::AdHoc.^find_method('message').wrap(%x{$language}<X::Comp::AdHoc>//ENGLISH);
say 'wrapped X::Comp::AdHoc';
X::Comp::BeginTime.^find_method('message').wrap(%x{$language}<X::Comp::BeginTime>//ENGLISH);
say 'wrapped X::Comp::BeginTime';
X::Comp::FailGoal.^find_method('message').wrap(%x{$language}<X::Comp::FailGoal>//ENGLISH);
say 'wrapped X::Comp::FailGoal';
X::Comp::Group.^find_method('message').wrap(%x{$language}<X::Comp::Group>//ENGLISH);
say 'wrapped X::Comp::Group';
X::Comp::WheneverOutOfScope.^find_method('message').wrap(%x{$language}<X::Comp::WheneverOutOfScope>//ENGLISH);
say 'wrapped X::Comp::WheneverOutOfScope';
X::CompUnit::UnsatisfiedDependency.^find_method('message').wrap(%x{$language}<X::CompUnit::UnsatisfiedDependency>//ENGLISH);
say 'wrapped X::CompUnit::UnsatisfiedDependency';
X::Composition::NotComposable.^find_method('message').wrap(%x{$language}<X::Composition::NotComposable>//ENGLISH);
say 'wrapped X::Composition::NotComposable';
X::Constructor::Positional.^find_method('message').wrap(%x{$language}<X::Constructor::Positional>//ENGLISH);
say 'wrapped X::Constructor::Positional';
X::ControlFlow.^find_method('message').wrap(%x{$language}<X::ControlFlow>//ENGLISH);
say 'wrapped X::ControlFlow';
X::ControlFlow.^find_method('message').wrap(%x{$language}<X::ControlFlow>//ENGLISH);
say 'wrapped X::ControlFlow';
X::ControlFlow::Return.^find_method('message').wrap(%x{$language}<X::ControlFlow::Return>//ENGLISH);
say 'wrapped X::ControlFlow::Return';
X::DateTime::InvalidDeltaUnit.^find_method('message').wrap(%x{$language}<X::DateTime::InvalidDeltaUnit>//ENGLISH);
say 'wrapped X::DateTime::InvalidDeltaUnit';
X::DateTime::TimezoneClash.^find_method('message').wrap(%x{$language}<X::DateTime::TimezoneClash>//ENGLISH);
say 'wrapped X::DateTime::TimezoneClash';
X::Declaration::OurScopeInRole.^find_method('message').wrap(%x{$language}<X::Declaration::OurScopeInRole>//ENGLISH);
say 'wrapped X::Declaration::OurScopeInRole';
X::Declaration::Scope.^find_method('message').wrap(%x{$language}<X::Declaration::Scope>//ENGLISH);
say 'wrapped X::Declaration::Scope';
X::Declaration::Scope::Multi.^find_method('message').wrap(%x{$language}<X::Declaration::Scope::Multi>//ENGLISH);
say 'wrapped X::Declaration::Scope::Multi';
X::Dynamic::NotFound.^find_method('message').wrap(%x{$language}<X::Dynamic::NotFound>//ENGLISH);
say 'wrapped X::Dynamic::NotFound';
X::Dynamic::Package.^find_method('message').wrap(%x{$language}<X::Dynamic::Package>//ENGLISH);
say 'wrapped X::Dynamic::Package';
X::Dynamic::Postdeclaration.^find_method('message').wrap(%x{$language}<X::Dynamic::Postdeclaration>//ENGLISH);
say 'wrapped X::Dynamic::Postdeclaration';
X::EXPORTHOW::Conflict.^find_method('message').wrap(%x{$language}<X::EXPORTHOW::Conflict>//ENGLISH);
say 'wrapped X::EXPORTHOW::Conflict';
X::EXPORTHOW::InvalidDirective.^find_method('message').wrap(%x{$language}<X::EXPORTHOW::InvalidDirective>//ENGLISH);
say 'wrapped X::EXPORTHOW::InvalidDirective';
X::EXPORTHOW::NothingToSupersede.^find_method('message').wrap(%x{$language}<X::EXPORTHOW::NothingToSupersede>//ENGLISH);
say 'wrapped X::EXPORTHOW::NothingToSupersede';
X::Encoding::AlreadyRegistered.^find_method('message').wrap(%x{$language}<X::Encoding::AlreadyRegistered>//ENGLISH);
say 'wrapped X::Encoding::AlreadyRegistered';
X::Encoding::Unknown.^find_method('message').wrap(%x{$language}<X::Encoding::Unknown>//ENGLISH);
say 'wrapped X::Encoding::Unknown';
X::Eval::NoSuchLang.^find_method('message').wrap(%x{$language}<X::Eval::NoSuchLang>//ENGLISH);
say 'wrapped X::Eval::NoSuchLang';
X::Exhausted.^find_method('message').wrap(%x{$language}<X::Exhausted>//ENGLISH);
say 'wrapped X::Exhausted';
X::Experimental.^find_method('message').wrap(%x{$language}<X::Experimental>//ENGLISH);
say 'wrapped X::Experimental';
X::Export::NameClash.^find_method('message').wrap(%x{$language}<X::Export::NameClash>//ENGLISH);
say 'wrapped X::Export::NameClash';
X::Hash::Store::OddNumber.^find_method('message').wrap(%x{$language}<X::Hash::Store::OddNumber>//ENGLISH);
say 'wrapped X::Hash::Store::OddNumber';
X::HyperOp::Infinite.^find_method('message').wrap(%x{$language}<X::HyperOp::Infinite>//ENGLISH);
say 'wrapped X::HyperOp::Infinite';
X::HyperOp::NonDWIM.^find_method('message').wrap(%x{$language}<X::HyperOp::NonDWIM>//ENGLISH);
say 'wrapped X::HyperOp::NonDWIM';
X::HyperWhatever::Multiple.^find_method('message').wrap(%x{$language}<X::HyperWhatever::Multiple>//ENGLISH);
say 'wrapped X::HyperWhatever::Multiple';
X::IO::BinaryAndEncoding.^find_method('message').wrap(%x{$language}<X::IO::BinaryAndEncoding>//ENGLISH);
say 'wrapped X::IO::BinaryAndEncoding';
X::IO::BinaryMode.^find_method('message').wrap(%x{$language}<X::IO::BinaryMode>//ENGLISH);
say 'wrapped X::IO::BinaryMode';
X::IO::Chdir.^find_method('message').wrap(%x{$language}<X::IO::Chdir>//ENGLISH);
say 'wrapped X::IO::Chdir';
X::IO::Chmod.^find_method('message').wrap(%x{$language}<X::IO::Chmod>//ENGLISH);
say 'wrapped X::IO::Chmod';
X::IO::Copy.^find_method('message').wrap(%x{$language}<X::IO::Copy>//ENGLISH);
say 'wrapped X::IO::Copy';
X::IO::Cwd.^find_method('message').wrap(%x{$language}<X::IO::Cwd>//ENGLISH);
say 'wrapped X::IO::Cwd';
X::IO::Dir.^find_method('message').wrap(%x{$language}<X::IO::Dir>//ENGLISH);
say 'wrapped X::IO::Dir';
X::IO::Directory.^find_method('message').wrap(%x{$language}<X::IO::Directory>//ENGLISH);
say 'wrapped X::IO::Directory';
X::IO::DoesNotExist.^find_method('message').wrap(%x{$language}<X::IO::DoesNotExist>//ENGLISH);
say 'wrapped X::IO::DoesNotExist';
X::IO::Flush.^find_method('message').wrap(%x{$language}<X::IO::Flush>//ENGLISH);
say 'wrapped X::IO::Flush';
X::IO::Link.^find_method('message').wrap(%x{$language}<X::IO::Link>//ENGLISH);
say 'wrapped X::IO::Link';
X::IO::Lock.^find_method('message').wrap(%x{$language}<X::IO::Lock>//ENGLISH);
say 'wrapped X::IO::Lock';
X::IO::Mkdir.^find_method('message').wrap(%x{$language}<X::IO::Mkdir>//ENGLISH);
say 'wrapped X::IO::Mkdir';
X::IO::Move.^find_method('message').wrap(%x{$language}<X::IO::Move>//ENGLISH);
say 'wrapped X::IO::Move';
X::IO::NotAChild.^find_method('message').wrap(%x{$language}<X::IO::NotAChild>//ENGLISH);
say 'wrapped X::IO::NotAChild';
X::IO::NotAFile.^find_method('message').wrap(%x{$language}<X::IO::NotAFile>//ENGLISH);
say 'wrapped X::IO::NotAFile';
X::IO::Null.^find_method('message').wrap(%x{$language}<X::IO::Null>//ENGLISH);
say 'wrapped X::IO::Null';
X::IO::Rename.^find_method('message').wrap(%x{$language}<X::IO::Rename>//ENGLISH);
say 'wrapped X::IO::Rename';
X::IO::Resolve.^find_method('message').wrap(%x{$language}<X::IO::Resolve>//ENGLISH);
say 'wrapped X::IO::Resolve';
X::IO::Rmdir.^find_method('message').wrap(%x{$language}<X::IO::Rmdir>//ENGLISH);
say 'wrapped X::IO::Rmdir';
X::IO::Symlink.^find_method('message').wrap(%x{$language}<X::IO::Symlink>//ENGLISH);
say 'wrapped X::IO::Symlink';
X::IO::Unknown.^find_method('message').wrap(%x{$language}<X::IO::Unknown>//ENGLISH);
say 'wrapped X::IO::Unknown';
X::IO::Unlink.^find_method('message').wrap(%x{$language}<X::IO::Unlink>//ENGLISH);
say 'wrapped X::IO::Unlink';
X::IllegalDimensionInShape.^find_method('message').wrap(%x{$language}<X::IllegalDimensionInShape>//ENGLISH);
say 'wrapped X::IllegalDimensionInShape';
X::IllegalOnFixedDimensionArray.^find_method('message').wrap(%x{$language}<X::IllegalOnFixedDimensionArray>//ENGLISH);
say 'wrapped X::IllegalOnFixedDimensionArray';
X::Immutable.^find_method('message').wrap(%x{$language}<X::Immutable>//ENGLISH);
say 'wrapped X::Immutable';
X::Import::MissingSymbols.^find_method('message').wrap(%x{$language}<X::Import::MissingSymbols>//ENGLISH);
say 'wrapped X::Import::MissingSymbols';
X::Import::NoSuchTag.^find_method('message').wrap(%x{$language}<X::Import::NoSuchTag>//ENGLISH);
say 'wrapped X::Import::NoSuchTag';
X::Import::OnlystarProto.^find_method('message').wrap(%x{$language}<X::Import::OnlystarProto>//ENGLISH);
say 'wrapped X::Import::OnlystarProto';
X::Import::Positional.^find_method('message').wrap(%x{$language}<X::Import::Positional>//ENGLISH);
say 'wrapped X::Import::Positional';
X::Import::Redeclaration.^find_method('message').wrap(%x{$language}<X::Import::Redeclaration>//ENGLISH);
say 'wrapped X::Import::Redeclaration';
X::Inheritance::NotComposed.^find_method('message').wrap(%x{$language}<X::Inheritance::NotComposed>//ENGLISH);
say 'wrapped X::Inheritance::NotComposed';
X::Inheritance::SelfInherit.^find_method('message').wrap(%x{$language}<X::Inheritance::SelfInherit>//ENGLISH);
say 'wrapped X::Inheritance::SelfInherit';
X::Inheritance::UnknownParent.^find_method('message').wrap(%x{$language}<X::Inheritance::UnknownParent>//ENGLISH);
say 'wrapped X::Inheritance::UnknownParent';
X::Inheritance::Unsupported.^find_method('message').wrap(%x{$language}<X::Inheritance::Unsupported>//ENGLISH);
say 'wrapped X::Inheritance::Unsupported';
X::Invalid::ComputedValue.^find_method('message').wrap(%x{$language}<X::Invalid::ComputedValue>//ENGLISH);
say 'wrapped X::Invalid::ComputedValue';
X::Invalid::Value.^find_method('message').wrap(%x{$language}<X::Invalid::Value>//ENGLISH);
say 'wrapped X::Invalid::Value';
X::InvalidType.^find_method('message').wrap(%x{$language}<X::InvalidType>//ENGLISH);
say 'wrapped X::InvalidType';
X::InvalidTypeSmiley.^find_method('message').wrap(%x{$language}<X::InvalidTypeSmiley>//ENGLISH);
say 'wrapped X::InvalidTypeSmiley';
X::Item.^find_method('message').wrap(%x{$language}<X::Item>//ENGLISH);
say 'wrapped X::Item';
X::Language::ModRequired.^find_method('message').wrap(%x{$language}<X::Language::ModRequired>//ENGLISH);
say 'wrapped X::Language::ModRequired';
X::Language::TooLate.^find_method('message').wrap(%x{$language}<X::Language::TooLate>//ENGLISH);
say 'wrapped X::Language::TooLate';
X::Language::Unsupported.^find_method('message').wrap(%x{$language}<X::Language::Unsupported>//ENGLISH);
say 'wrapped X::Language::Unsupported';
X::LibEmpty.^find_method('message').wrap(%x{$language}<X::LibEmpty>//ENGLISH);
say 'wrapped X::LibEmpty';
X::LibNone.^find_method('message').wrap(%x{$language}<X::LibNone>//ENGLISH);
say 'wrapped X::LibNone';
X::Localizer::NoContainer.^find_method('message').wrap(%x{$language}<X::Localizer::NoContainer>//ENGLISH);
say 'wrapped X::Localizer::NoContainer';
X::Match::Bool.^find_method('message').wrap(%x{$language}<X::Match::Bool>//ENGLISH);
say 'wrapped X::Match::Bool';
X::Method::InvalidQualifier.^find_method('message').wrap(%x{$language}<X::Method::InvalidQualifier>//ENGLISH);
say 'wrapped X::Method::InvalidQualifier';
X::Method::NotFound.^find_method('message').wrap(%x{$language}<X::Method::NotFound>//ENGLISH);
say 'wrapped X::Method::NotFound';
X::Method::Private::Permission.^find_method('message').wrap(%x{$language}<X::Method::Private::Permission>//ENGLISH);
say 'wrapped X::Method::Private::Permission';
X::Method::Private::Unqualified.^find_method('message').wrap(%x{$language}<X::Method::Private::Unqualified>//ENGLISH);
say 'wrapped X::Method::Private::Unqualified';
X::Mixin::NotComposable.^find_method('message').wrap(%x{$language}<X::Mixin::NotComposable>//ENGLISH);
say 'wrapped X::Mixin::NotComposable';
X::Multi::Ambiguous.^find_method('message').wrap(%x{$language}<X::Multi::Ambiguous>//ENGLISH);
say 'wrapped X::Multi::Ambiguous';
X::Multi::NoMatch.^find_method('message').wrap(%x{$language}<X::Multi::NoMatch>//ENGLISH);
say 'wrapped X::Multi::NoMatch';
X::MultipleTypeSmiley.^find_method('message').wrap(%x{$language}<X::MultipleTypeSmiley>//ENGLISH);
say 'wrapped X::MultipleTypeSmiley';
X::MustBeParametric.^find_method('message').wrap(%x{$language}<X::MustBeParametric>//ENGLISH);
say 'wrapped X::MustBeParametric';
X::NQP::NotFound.^find_method('message').wrap(%x{$language}<X::NQP::NotFound>//ENGLISH);
say 'wrapped X::NQP::NotFound';
X::NYI.^find_method('message').wrap(%x{$language}<X::NYI>//ENGLISH);
say 'wrapped X::NYI';
X::NYI::Available.^find_method('message').wrap(%x{$language}<X::NYI::Available>//ENGLISH);
say 'wrapped X::NYI::Available';
X::NYI::BigInt.^find_method('message').wrap(%x{$language}<X::NYI::BigInt>//ENGLISH);
say 'wrapped X::NYI::BigInt';
X::NoCoreRevision.^find_method('message').wrap(%x{$language}<X::NoCoreRevision>//ENGLISH);
say 'wrapped X::NoCoreRevision';
X::NoDispatcher.^find_method('message').wrap(%x{$language}<X::NoDispatcher>//ENGLISH);
say 'wrapped X::NoDispatcher';
X::NoSuchSymbol.^find_method('message').wrap(%x{$language}<X::NoSuchSymbol>//ENGLISH);
say 'wrapped X::NoSuchSymbol';
X::NotEnoughDimensions.^find_method('message').wrap(%x{$language}<X::NotEnoughDimensions>//ENGLISH);
say 'wrapped X::NotEnoughDimensions';
X::NotParametric.^find_method('message').wrap(%x{$language}<X::NotParametric>//ENGLISH);
say 'wrapped X::NotParametric';
X::Numeric::CannotConvert.^find_method('message').wrap(%x{$language}<X::Numeric::CannotConvert>//ENGLISH);
say 'wrapped X::Numeric::CannotConvert';
X::Numeric::Confused.^find_method('message').wrap(%x{$language}<X::Numeric::Confused>//ENGLISH);
say 'wrapped X::Numeric::Confused';
X::Numeric::DivideByZero.^find_method('message').wrap(%x{$language}<X::Numeric::DivideByZero>//ENGLISH);
say 'wrapped X::Numeric::DivideByZero';
X::Numeric::Overflow.^find_method('message').wrap(%x{$language}<X::Numeric::Overflow>//ENGLISH);
say 'wrapped X::Numeric::Overflow';
X::Numeric::Real.^find_method('message').wrap(%x{$language}<X::Numeric::Real>//ENGLISH);
say 'wrapped X::Numeric::Real';
X::Numeric::Underflow.^find_method('message').wrap(%x{$language}<X::Numeric::Underflow>//ENGLISH);
say 'wrapped X::Numeric::Underflow';
X::Obsolete.^find_method('message').wrap(%x{$language}<X::Obsolete>//ENGLISH);
say 'wrapped X::Obsolete';
X::OutOfRange.^find_method('message').wrap(%x{$language}<X::OutOfRange>//ENGLISH);
say 'wrapped X::OutOfRange';
X::Package::Stubbed.^find_method('message').wrap(%x{$language}<X::Package::Stubbed>//ENGLISH);
say 'wrapped X::Package::Stubbed';
X::Package::UseLib.^find_method('message').wrap(%x{$language}<X::Package::UseLib>//ENGLISH);
say 'wrapped X::Package::UseLib';
X::Pairup::OddNumber.^find_method('message').wrap(%x{$language}<X::Pairup::OddNumber>//ENGLISH);
say 'wrapped X::Pairup::OddNumber';
X::Parameter::AfterDefault.^find_method('message').wrap(%x{$language}<X::Parameter::AfterDefault>//ENGLISH);
say 'wrapped X::Parameter::AfterDefault';
X::Parameter::BadType.^find_method('message').wrap(%x{$language}<X::Parameter::BadType>//ENGLISH);
say 'wrapped X::Parameter::BadType';
X::Parameter::Default.^find_method('message').wrap(%x{$language}<X::Parameter::Default>//ENGLISH);
say 'wrapped X::Parameter::Default';
X::Parameter::Default::TypeCheck.^find_method('message').wrap(%x{$language}<X::Parameter::Default::TypeCheck>//ENGLISH);
say 'wrapped X::Parameter::Default::TypeCheck';
X::Parameter::InvalidConcreteness.^find_method('message').wrap(%x{$language}<X::Parameter::InvalidConcreteness>//ENGLISH);
say 'wrapped X::Parameter::InvalidConcreteness';
X::Parameter::InvalidType.^find_method('message').wrap(%x{$language}<X::Parameter::InvalidType>//ENGLISH);
say 'wrapped X::Parameter::InvalidType';
X::Parameter::MultipleTypeConstraints.^find_method('message').wrap(%x{$language}<X::Parameter::MultipleTypeConstraints>//ENGLISH);
say 'wrapped X::Parameter::MultipleTypeConstraints';
X::Parameter::Placeholder.^find_method('message').wrap(%x{$language}<X::Parameter::Placeholder>//ENGLISH);
say 'wrapped X::Parameter::Placeholder';
X::Parameter::RW.^find_method('message').wrap(%x{$language}<X::Parameter::RW>//ENGLISH);
say 'wrapped X::Parameter::RW';
X::Parameter::Twigil.^find_method('message').wrap(%x{$language}<X::Parameter::Twigil>//ENGLISH);
say 'wrapped X::Parameter::Twigil';
X::Parameter::TypedSlurpy.^find_method('message').wrap(%x{$language}<X::Parameter::TypedSlurpy>//ENGLISH);
say 'wrapped X::Parameter::TypedSlurpy';
X::Parameter::WrongOrder.^find_method('message').wrap(%x{$language}<X::Parameter::WrongOrder>//ENGLISH);
say 'wrapped X::Parameter::WrongOrder';
X::ParametricConstant.^find_method('message').wrap(%x{$language}<X::ParametricConstant>//ENGLISH);
say 'wrapped X::ParametricConstant';
X::Phaser::Multiple.^find_method('message').wrap(%x{$language}<X::Phaser::Multiple>//ENGLISH);
say 'wrapped X::Phaser::Multiple';
X::Phaser::PrePost.^find_method('message').wrap(%x{$language}<X::Phaser::PrePost>//ENGLISH);
say 'wrapped X::Phaser::PrePost';
X::PhaserExceptions.^find_method('message').wrap(%x{$language}<X::PhaserExceptions>//ENGLISH);
say 'wrapped X::PhaserExceptions';
X::Placeholder::Attribute.^find_method('message').wrap(%x{$language}<X::Placeholder::Attribute>//ENGLISH);
say 'wrapped X::Placeholder::Attribute';
X::Placeholder::Block.^find_method('message').wrap(%x{$language}<X::Placeholder::Block>//ENGLISH);
say 'wrapped X::Placeholder::Block';
X::Placeholder::Mainline.^find_method('message').wrap(%x{$language}<X::Placeholder::Mainline>//ENGLISH);
say 'wrapped X::Placeholder::Mainline';
X::Placeholder::NonPlaceholder.^find_method('message').wrap(%x{$language}<X::Placeholder::NonPlaceholder>//ENGLISH);
say 'wrapped X::Placeholder::NonPlaceholder';
X::PoisonedAlias.^find_method('message').wrap(%x{$language}<X::PoisonedAlias>//ENGLISH);
say 'wrapped X::PoisonedAlias';
X::Pragma::CannotPrecomp.^find_method('message').wrap(%x{$language}<X::Pragma::CannotPrecomp>//ENGLISH);
say 'wrapped X::Pragma::CannotPrecomp';
X::Pragma::CannotWhat.^find_method('message').wrap(%x{$language}<X::Pragma::CannotWhat>//ENGLISH);
say 'wrapped X::Pragma::CannotWhat';
X::Pragma::MustOneOf.^find_method('message').wrap(%x{$language}<X::Pragma::MustOneOf>//ENGLISH);
say 'wrapped X::Pragma::MustOneOf';
X::Pragma::NoArgs.^find_method('message').wrap(%x{$language}<X::Pragma::NoArgs>//ENGLISH);
say 'wrapped X::Pragma::NoArgs';
X::Pragma::OnlyOne.^find_method('message').wrap(%x{$language}<X::Pragma::OnlyOne>//ENGLISH);
say 'wrapped X::Pragma::OnlyOne';
X::Pragma::UnknownArg.^find_method('message').wrap(%x{$language}<X::Pragma::UnknownArg>//ENGLISH);
say 'wrapped X::Pragma::UnknownArg';
X::Proc::Unsuccessful.^find_method('message').wrap(%x{$language}<X::Proc::Unsuccessful>//ENGLISH);
say 'wrapped X::Proc::Unsuccessful';
X::PseudoPackage::InDeclaration.^find_method('message').wrap(%x{$language}<X::PseudoPackage::InDeclaration>//ENGLISH);
say 'wrapped X::PseudoPackage::InDeclaration';
X::Range::InvalidArg.^find_method('message').wrap(%x{$language}<X::Range::InvalidArg>//ENGLISH);
say 'wrapped X::Range::InvalidArg';
X::Redeclaration.^find_method('message').wrap(%x{$language}<X::Redeclaration>//ENGLISH);
say 'wrapped X::Redeclaration';
X::Redeclaration::Outer.^find_method('message').wrap(%x{$language}<X::Redeclaration::Outer>//ENGLISH);
say 'wrapped X::Redeclaration::Outer';
X::Role::Initialization.^find_method('message').wrap(%x{$language}<X::Role::Initialization>//ENGLISH);
say 'wrapped X::Role::Initialization';
X::Role::Parametric::NoSuchCandidate.^find_method('message').wrap(%x{$language}<X::Role::Parametric::NoSuchCandidate>//ENGLISH);
say 'wrapped X::Role::Parametric::NoSuchCandidate';
X::Routine::Unwrap.^find_method('message').wrap(%x{$language}<X::Routine::Unwrap>//ENGLISH);
say 'wrapped X::Routine::Unwrap';
X::SecurityPolicy.^find_method('message').wrap(%x{$language}<X::SecurityPolicy>//ENGLISH);
say 'wrapped X::SecurityPolicy';
X::SecurityPolicy::Eval.^find_method('message').wrap(%x{$language}<X::SecurityPolicy::Eval>//ENGLISH);
say 'wrapped X::SecurityPolicy::Eval';
X::Seq::Consumed.^find_method('message').wrap(%x{$language}<X::Seq::Consumed>//ENGLISH);
say 'wrapped X::Seq::Consumed';
X::Seq::NotIndexable.^find_method('message').wrap(%x{$language}<X::Seq::NotIndexable>//ENGLISH);
say 'wrapped X::Seq::NotIndexable';
X::Sequence::Deduction.^find_method('message').wrap(%x{$language}<X::Sequence::Deduction>//ENGLISH);
say 'wrapped X::Sequence::Deduction';
X::Sequence::Endpoint.^find_method('message').wrap(%x{$language}<X::Sequence::Endpoint>//ENGLISH);
say 'wrapped X::Sequence::Endpoint';
X::Set::Coerce.^find_method('message').wrap(%x{$language}<X::Set::Coerce>//ENGLISH);
say 'wrapped X::Set::Coerce';
X::Signature::NameClash.^find_method('message').wrap(%x{$language}<X::Signature::NameClash>//ENGLISH);
say 'wrapped X::Signature::NameClash';
X::Signature::Placeholder.^find_method('message').wrap(%x{$language}<X::Signature::Placeholder>//ENGLISH);
say 'wrapped X::Signature::Placeholder';
X::Str::InvalidCharName.^find_method('message').wrap(%x{$language}<X::Str::InvalidCharName>//ENGLISH);
say 'wrapped X::Str::InvalidCharName';
X::Str::Match::x.^find_method('message').wrap(%x{$language}<X::Str::Match::x>//ENGLISH);
say 'wrapped X::Str::Match::x';
X::Str::Numeric.^find_method('message').wrap(%x{$language}<X::Str::Numeric>//ENGLISH);
say 'wrapped X::Str::Numeric';
X::Str::Sprintf::Directives::BadType.^find_method('message').wrap(%x{$language}<X::Str::Sprintf::Directives::BadType>//ENGLISH);
say 'wrapped X::Str::Sprintf::Directives::BadType';
X::Str::Sprintf::Directives::Count.^find_method('message').wrap(%x{$language}<X::Str::Sprintf::Directives::Count>//ENGLISH);
say 'wrapped X::Str::Sprintf::Directives::Count';
X::Str::Sprintf::Directives::Unsupported.^find_method('message').wrap(%x{$language}<X::Str::Sprintf::Directives::Unsupported>//ENGLISH);
say 'wrapped X::Str::Sprintf::Directives::Unsupported';
X::Str::Subst::Adverb.^find_method('message').wrap(%x{$language}<X::Str::Subst::Adverb>//ENGLISH);
say 'wrapped X::Str::Subst::Adverb';
X::Str::Trans::IllegalKey.^find_method('message').wrap(%x{$language}<X::Str::Trans::IllegalKey>//ENGLISH);
say 'wrapped X::Str::Trans::IllegalKey';
X::Str::Trans::InvalidArg.^find_method('message').wrap(%x{$language}<X::Str::Trans::InvalidArg>//ENGLISH);
say 'wrapped X::Str::Trans::InvalidArg';
X::StubCode.^find_method('message').wrap(%x{$language}<X::StubCode>//ENGLISH);
say 'wrapped X::StubCode';
X::Subscript::Negative.^find_method('message').wrap(%x{$language}<X::Subscript::Negative>//ENGLISH);
say 'wrapped X::Subscript::Negative';
X::Syntax::AddCategorical::TooFewParts.^find_method('message').wrap(%x{$language}<X::Syntax::AddCategorical::TooFewParts>//ENGLISH);
say 'wrapped X::Syntax::AddCategorical::TooFewParts';
X::Syntax::AddCategorical::TooManyParts.^find_method('message').wrap(%x{$language}<X::Syntax::AddCategorical::TooManyParts>//ENGLISH);
say 'wrapped X::Syntax::AddCategorical::TooManyParts';
X::Syntax::Adverb.^find_method('message').wrap(%x{$language}<X::Syntax::Adverb>//ENGLISH);
say 'wrapped X::Syntax::Adverb';
X::Syntax::Argument::MOPMacro.^find_method('message').wrap(%x{$language}<X::Syntax::Argument::MOPMacro>//ENGLISH);
say 'wrapped X::Syntax::Argument::MOPMacro';
X::Syntax::Augment::Adverb.^find_method('message').wrap(%x{$language}<X::Syntax::Augment::Adverb>//ENGLISH);
say 'wrapped X::Syntax::Augment::Adverb';
X::Syntax::Augment::Illegal.^find_method('message').wrap(%x{$language}<X::Syntax::Augment::Illegal>//ENGLISH);
say 'wrapped X::Syntax::Augment::Illegal';
X::Syntax::Augment::WithoutMonkeyTyping.^find_method('message').wrap(%x{$language}<X::Syntax::Augment::WithoutMonkeyTyping>//ENGLISH);
say 'wrapped X::Syntax::Augment::WithoutMonkeyTyping';
X::Syntax::BlockGobbled.^find_method('message').wrap(%x{$language}<X::Syntax::BlockGobbled>//ENGLISH);
say 'wrapped X::Syntax::BlockGobbled';
X::Syntax::CannotMeta.^find_method('message').wrap(%x{$language}<X::Syntax::CannotMeta>//ENGLISH);
say 'wrapped X::Syntax::CannotMeta';
X::Syntax::Coercer::TooComplex.^find_method('message').wrap(%x{$language}<X::Syntax::Coercer::TooComplex>//ENGLISH);
say 'wrapped X::Syntax::Coercer::TooComplex';
X::Syntax::Comment::Embedded.^find_method('message').wrap(%x{$language}<X::Syntax::Comment::Embedded>//ENGLISH);
say 'wrapped X::Syntax::Comment::Embedded';
X::Syntax::ConditionalOperator::PrecedenceTooLoose.^find_method('message').wrap(%x{$language}<X::Syntax::ConditionalOperator::PrecedenceTooLoose>//ENGLISH);
say 'wrapped X::Syntax::ConditionalOperator::PrecedenceTooLoose';
X::Syntax::ConditionalOperator::SecondPartGobbled.^find_method('message').wrap(%x{$language}<X::Syntax::ConditionalOperator::SecondPartGobbled>//ENGLISH);
say 'wrapped X::Syntax::ConditionalOperator::SecondPartGobbled';
X::Syntax::ConditionalOperator::SecondPartInvalid.^find_method('message').wrap(%x{$language}<X::Syntax::ConditionalOperator::SecondPartInvalid>//ENGLISH);
say 'wrapped X::Syntax::ConditionalOperator::SecondPartInvalid';
X::Syntax::Confused.^find_method('message').wrap(%x{$language}<X::Syntax::Confused>//ENGLISH);
say 'wrapped X::Syntax::Confused';
X::Syntax::DuplicatedPrefix.^find_method('message').wrap(%x{$language}<X::Syntax::DuplicatedPrefix>//ENGLISH);
say 'wrapped X::Syntax::DuplicatedPrefix';
X::Syntax::Extension::Category.^find_method('message').wrap(%x{$language}<X::Syntax::Extension::Category>//ENGLISH);
say 'wrapped X::Syntax::Extension::Category';
X::Syntax::Extension::Null.^find_method('message').wrap(%x{$language}<X::Syntax::Extension::Null>//ENGLISH);
say 'wrapped X::Syntax::Extension::Null';
X::Syntax::Extension::SpecialForm.^find_method('message').wrap(%x{$language}<X::Syntax::Extension::SpecialForm>//ENGLISH);
say 'wrapped X::Syntax::Extension::SpecialForm';
X::Syntax::Extension::TooComplex.^find_method('message').wrap(%x{$language}<X::Syntax::Extension::TooComplex>//ENGLISH);
say 'wrapped X::Syntax::Extension::TooComplex';
X::Syntax::InfixInTermPosition.^find_method('message').wrap(%x{$language}<X::Syntax::InfixInTermPosition>//ENGLISH);
say 'wrapped X::Syntax::InfixInTermPosition';
X::Syntax::KeywordAsFunction.^find_method('message').wrap(%x{$language}<X::Syntax::KeywordAsFunction>//ENGLISH);
say 'wrapped X::Syntax::KeywordAsFunction';
X::Syntax::Malformed.^find_method('message').wrap(%x{$language}<X::Syntax::Malformed>//ENGLISH);
say 'wrapped X::Syntax::Malformed';
X::Syntax::Malformed::Elsif.^find_method('message').wrap(%x{$language}<X::Syntax::Malformed::Elsif>//ENGLISH);
say 'wrapped X::Syntax::Malformed::Elsif';
X::Syntax::Missing.^find_method('message').wrap(%x{$language}<X::Syntax::Missing>//ENGLISH);
say 'wrapped X::Syntax::Missing';
X::Syntax::Name::Null.^find_method('message').wrap(%x{$language}<X::Syntax::Name::Null>//ENGLISH);
say 'wrapped X::Syntax::Name::Null';
X::Syntax::NegatedPair.^find_method('message').wrap(%x{$language}<X::Syntax::NegatedPair>//ENGLISH);
say 'wrapped X::Syntax::NegatedPair';
X::Syntax::NoSelf.^find_method('message').wrap(%x{$language}<X::Syntax::NoSelf>//ENGLISH);
say 'wrapped X::Syntax::NoSelf';
X::Syntax::NonAssociative.^find_method('message').wrap(%x{$language}<X::Syntax::NonAssociative>//ENGLISH);
say 'wrapped X::Syntax::NonAssociative';
X::Syntax::NonListAssociative.^find_method('message').wrap(%x{$language}<X::Syntax::NonListAssociative>//ENGLISH);
say 'wrapped X::Syntax::NonListAssociative';
X::Syntax::Number::IllegalDecimal.^find_method('message').wrap(%x{$language}<X::Syntax::Number::IllegalDecimal>//ENGLISH);
say 'wrapped X::Syntax::Number::IllegalDecimal';
X::Syntax::Number::LiteralType.^find_method('message').wrap(%x{$language}<X::Syntax::Number::LiteralType>//ENGLISH);
say 'wrapped X::Syntax::Number::LiteralType';
X::Syntax::Number::RadixOutOfRange.^find_method('message').wrap(%x{$language}<X::Syntax::Number::RadixOutOfRange>//ENGLISH);
say 'wrapped X::Syntax::Number::RadixOutOfRange';
X::Syntax::P5.^find_method('message').wrap(%x{$language}<X::Syntax::P5>//ENGLISH);
say 'wrapped X::Syntax::P5';
X::Syntax::ParentAsHash.^find_method('message').wrap(%x{$language}<X::Syntax::ParentAsHash>//ENGLISH);
say 'wrapped X::Syntax::ParentAsHash';
X::Syntax::Perl5Var.^find_method('message').wrap(%x{$language}<X::Syntax::Perl5Var>//ENGLISH);
say 'wrapped X::Syntax::Perl5Var';
X::Syntax::Pod::DeclaratorLeading.^find_method('message').wrap(%x{$language}<X::Syntax::Pod::DeclaratorLeading>//ENGLISH);
say 'wrapped X::Syntax::Pod::DeclaratorLeading';
X::Syntax::Pod::DeclaratorTrailing.^find_method('message').wrap(%x{$language}<X::Syntax::Pod::DeclaratorTrailing>//ENGLISH);
say 'wrapped X::Syntax::Pod::DeclaratorTrailing';
X::Syntax::Regex::Adverb.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::Adverb>//ENGLISH);
say 'wrapped X::Syntax::Regex::Adverb';
X::Syntax::Regex::Alias::LongName.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::Alias::LongName>//ENGLISH);
say 'wrapped X::Syntax::Regex::Alias::LongName';
X::Syntax::Regex::MalformedRange.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::MalformedRange>//ENGLISH);
say 'wrapped X::Syntax::Regex::MalformedRange';
X::Syntax::Regex::NonQuantifiable.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::NonQuantifiable>//ENGLISH);
say 'wrapped X::Syntax::Regex::NonQuantifiable';
X::Syntax::Regex::NullRegex.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::NullRegex>//ENGLISH);
say 'wrapped X::Syntax::Regex::NullRegex';
X::Syntax::Regex::QuantifierValue.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::QuantifierValue>//ENGLISH);
say 'wrapped X::Syntax::Regex::QuantifierValue';
X::Syntax::Regex::SolitaryBacktrackControl.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::SolitaryBacktrackControl>//ENGLISH);
say 'wrapped X::Syntax::Regex::SolitaryBacktrackControl';
X::Syntax::Regex::SolitaryQuantifier.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::SolitaryQuantifier>//ENGLISH);
say 'wrapped X::Syntax::Regex::SolitaryQuantifier';
X::Syntax::Regex::SpacesInBareRange.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::SpacesInBareRange>//ENGLISH);
say 'wrapped X::Syntax::Regex::SpacesInBareRange';
X::Syntax::Regex::UnrecognizedMetachar.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::UnrecognizedMetachar>//ENGLISH);
say 'wrapped X::Syntax::Regex::UnrecognizedMetachar';
X::Syntax::Regex::UnrecognizedModifier.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::UnrecognizedModifier>//ENGLISH);
say 'wrapped X::Syntax::Regex::UnrecognizedModifier';
X::Syntax::Regex::Unspace.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::Unspace>//ENGLISH);
say 'wrapped X::Syntax::Regex::Unspace';
X::Syntax::Regex::Unterminated.^find_method('message').wrap(%x{$language}<X::Syntax::Regex::Unterminated>//ENGLISH);
say 'wrapped X::Syntax::Regex::Unterminated';
X::Syntax::Reserved.^find_method('message').wrap(%x{$language}<X::Syntax::Reserved>//ENGLISH);
say 'wrapped X::Syntax::Reserved';
X::Syntax::Self::WithoutObject.^find_method('message').wrap(%x{$language}<X::Syntax::Self::WithoutObject>//ENGLISH);
say 'wrapped X::Syntax::Self::WithoutObject';
X::Syntax::Signature::InvocantMarker.^find_method('message').wrap(%x{$language}<X::Syntax::Signature::InvocantMarker>//ENGLISH);
say 'wrapped X::Syntax::Signature::InvocantMarker';
X::Syntax::Signature::InvocantNotAllowed.^find_method('message').wrap(%x{$language}<X::Syntax::Signature::InvocantNotAllowed>//ENGLISH);
say 'wrapped X::Syntax::Signature::InvocantNotAllowed';
X::Syntax::Term::MissingInitializer.^find_method('message').wrap(%x{$language}<X::Syntax::Term::MissingInitializer>//ENGLISH);
say 'wrapped X::Syntax::Term::MissingInitializer';
X::Syntax::Type::Adverb.^find_method('message').wrap(%x{$language}<X::Syntax::Type::Adverb>//ENGLISH);
say 'wrapped X::Syntax::Type::Adverb';
X::Syntax::UnlessElse.^find_method('message').wrap(%x{$language}<X::Syntax::UnlessElse>//ENGLISH);
say 'wrapped X::Syntax::UnlessElse';
X::Syntax::Variable::BadType.^find_method('message').wrap(%x{$language}<X::Syntax::Variable::BadType>//ENGLISH);
say 'wrapped X::Syntax::Variable::BadType';
X::Syntax::Variable::ConflictingTypes.^find_method('message').wrap(%x{$language}<X::Syntax::Variable::ConflictingTypes>//ENGLISH);
say 'wrapped X::Syntax::Variable::ConflictingTypes';
X::Syntax::Variable::IndirectDeclaration.^find_method('message').wrap(%x{$language}<X::Syntax::Variable::IndirectDeclaration>//ENGLISH);
say 'wrapped X::Syntax::Variable::IndirectDeclaration';
X::Syntax::Variable::Initializer.^find_method('message').wrap(%x{$language}<X::Syntax::Variable::Initializer>//ENGLISH);
say 'wrapped X::Syntax::Variable::Initializer';
X::Syntax::Variable::Match.^find_method('message').wrap(%x{$language}<X::Syntax::Variable::Match>//ENGLISH);
say 'wrapped X::Syntax::Variable::Match';
X::Syntax::Variable::MissingInitializer.^find_method('message').wrap(%x{$language}<X::Syntax::Variable::MissingInitializer>//ENGLISH);
say 'wrapped X::Syntax::Variable::MissingInitializer';
X::Syntax::Variable::Numeric.^find_method('message').wrap(%x{$language}<X::Syntax::Variable::Numeric>//ENGLISH);
say 'wrapped X::Syntax::Variable::Numeric';
X::Syntax::Variable::Twigil.^find_method('message').wrap(%x{$language}<X::Syntax::Variable::Twigil>//ENGLISH);
say 'wrapped X::Syntax::Variable::Twigil';
X::Syntax::VirtualCall.^find_method('message').wrap(%x{$language}<X::Syntax::VirtualCall>//ENGLISH);
say 'wrapped X::Syntax::VirtualCall';
X::Syntax::WithoutElse.^find_method('message').wrap(%x{$language}<X::Syntax::WithoutElse>//ENGLISH);
say 'wrapped X::Syntax::WithoutElse';
X::Temporal::InvalidFormat.^find_method('message').wrap(%x{$language}<X::Temporal::InvalidFormat>//ENGLISH);
say 'wrapped X::Temporal::InvalidFormat';
X::TooLateForREPR.^find_method('message').wrap(%x{$language}<X::TooLateForREPR>//ENGLISH);
say 'wrapped X::TooLateForREPR';
X::TooManyDimensions.^find_method('message').wrap(%x{$language}<X::TooManyDimensions>//ENGLISH);
say 'wrapped X::TooManyDimensions';
X::Trait::Invalid.^find_method('message').wrap(%x{$language}<X::Trait::Invalid>//ENGLISH);
say 'wrapped X::Trait::Invalid';
X::Trait::NotOnNative.^find_method('message').wrap(%x{$language}<X::Trait::NotOnNative>//ENGLISH);
say 'wrapped X::Trait::NotOnNative';
X::Trait::Scope.^find_method('message').wrap(%x{$language}<X::Trait::Scope>//ENGLISH);
say 'wrapped X::Trait::Scope';
X::Trait::Unknown.^find_method('message').wrap(%x{$language}<X::Trait::Unknown>//ENGLISH);
say 'wrapped X::Trait::Unknown';
X::TypeCheck.^find_method('message').wrap(%x{$language}<X::TypeCheck>//ENGLISH);
say 'wrapped X::TypeCheck';
X::TypeCheck::Argument.^find_method('message').wrap(%x{$language}<X::TypeCheck::Argument>//ENGLISH);
say 'wrapped X::TypeCheck::Argument';
X::TypeCheck::Assignment.^find_method('message').wrap(%x{$language}<X::TypeCheck::Assignment>//ENGLISH);
say 'wrapped X::TypeCheck::Assignment';
X::TypeCheck::Binding.^find_method('message').wrap(%x{$language}<X::TypeCheck::Binding>//ENGLISH);
say 'wrapped X::TypeCheck::Binding';
X::TypeCheck::Binding::Parameter.^find_method('message').wrap(%x{$language}<X::TypeCheck::Binding::Parameter>//ENGLISH);
say 'wrapped X::TypeCheck::Binding::Parameter';
X::TypeCheck::Return.^find_method('message').wrap(%x{$language}<X::TypeCheck::Return>//ENGLISH);
say 'wrapped X::TypeCheck::Return';
X::Undeclared.^find_method('message').wrap(%x{$language}<X::Undeclared>//ENGLISH);
say 'wrapped X::Undeclared';
X::Undeclared::Symbols.^find_method('message').wrap(%x{$language}<X::Undeclared::Symbols>//ENGLISH);
say 'wrapped X::Undeclared::Symbols';
X::UnitScope::Invalid.^find_method('message').wrap(%x{$language}<X::UnitScope::Invalid>//ENGLISH);
say 'wrapped X::UnitScope::Invalid';
X::UnitScope::TooLate.^find_method('message').wrap(%x{$language}<X::UnitScope::TooLate>//ENGLISH);
say 'wrapped X::UnitScope::TooLate';
X::Value::Dynamic.^find_method('message').wrap(%x{$language}<X::Value::Dynamic>//ENGLISH);
say 'wrapped X::Value::Dynamic';
X::WheneverOutOfScope.^find_method('message').wrap(%x{$language}<X::WheneverOutOfScope>//ENGLISH);
say 'wrapped X::WheneverOutOfScope';
X::Worry.^find_method('message').wrap(%x{$language}<X::Worry>//ENGLISH);
say 'wrapped X::Worry';
X::Worry::P5.^find_method('message').wrap(%x{$language}<X::Worry::P5>//ENGLISH);
say 'wrapped X::Worry::P5';
X::Worry::P5::BackReference.^find_method('message').wrap(%x{$language}<X::Worry::P5::BackReference>//ENGLISH);
say 'wrapped X::Worry::P5::BackReference';
X::Worry::P5::LeadingZero.^find_method('message').wrap(%x{$language}<X::Worry::P5::LeadingZero>//ENGLISH);
say 'wrapped X::Worry::P5::LeadingZero';
X::Worry::P5::Reference.^find_method('message').wrap(%x{$language}<X::Worry::P5::Reference>//ENGLISH);
say 'wrapped X::Worry::P5::Reference';
X::Worry::Precedence::Range.^find_method('message').wrap(%x{$language}<X::Worry::Precedence::Range>//ENGLISH);
say 'wrapped X::Worry::Precedence::Range';
